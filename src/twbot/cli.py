#!/usr/bin/env python3
"""CLI entry point for TW2002 bot.

Usage:
    tw2002-bot --config config.yaml
    tw2002-bot --generate-config
"""

from __future__ import annotations

import argparse
import asyncio
import logging
import sys
from pathlib import Path

from twbot.config import BotConfig, load_config


def setup_logging(verbose: bool = False) -> None:
    """Configure logging for the bot."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="TW2002 Trading Bot - Automated TradeWars 2002 player",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Generate a default config file
    tw2002-bot --generate-config > my_config.yaml

    # Run with config file
    tw2002-bot --config my_config.yaml

    # Run with verbose logging
    tw2002-bot --config my_config.yaml --verbose

    # Override host/port
    tw2002-bot --config my_config.yaml --host localhost --port 3003
""",
    )

    parser.add_argument(
        "-c", "--config",
        type=Path,
        help="Path to YAML configuration file",
    )
    parser.add_argument(
        "--generate-config",
        action="store_true",
        help="Generate a default config file and exit",
    )
    parser.add_argument(
        "--host",
        type=str,
        help="Override server host from config",
    )
    parser.add_argument(
        "--port",
        type=int,
        help="Override server port from config",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose logging",
    )
    parser.add_argument(
        "--strategy",
        choices=["profitable_pairs", "opportunistic", "twerk_optimized"],
        help="Override trading strategy from config",
    )
    parser.add_argument(
        "--target-credits",
        type=int,
        help="Override target credits from config",
    )
    parser.add_argument(
        "--max-turns",
        type=int,
        help="Override max turns per session from config",
    )

    return parser.parse_args()


def generate_default_config() -> str:
    """Generate default config as YAML string."""
    import yaml

    config = BotConfig()
    data = config._to_dict()

    # Add comments
    output = """# TW2002 Bot Configuration
# Generated by tw2002-bot --generate-config

"""
    output += yaml.dump(data, default_flow_style=False, sort_keys=False)
    return output


async def run_bot(config: BotConfig) -> None:
    """Run the trading bot with the given configuration."""
    from twbot.bot import TradingBot
    from twbot.multi_character import MultiCharacterManager
    from twbot.character import CharacterManager

    print("\n" + "=" * 60)
    print("TW2002 TRADING BOT")
    print("=" * 60)
    print(f"Strategy: {config.trading.strategy}")
    print(f"Target: {config.session.target_credits:,} credits")
    print(f"Max turns: {config.session.max_turns_per_session}")
    print("=" * 60 + "\n")

    # Set up data directory
    from mcp_bbs.config import get_default_knowledge_root
    knowledge_root = get_default_knowledge_root()
    data_dir = knowledge_root / "tw2002" / f"{config.connection.host}_{config.connection.port}"
    data_dir.mkdir(parents=True, exist_ok=True)

    # Initialize multi-character manager
    multi_char = MultiCharacterManager(
        config=config,
        data_dir=data_dir,
        sharing_mode=config.multi_character.knowledge_sharing,
    )

    # Track overall session stats
    total_characters = 0
    total_profit = 0

    while total_characters < config.multi_character.max_characters:
        total_characters += 1

        # Create or load character
        char_state = multi_char.create_character()
        print(f"\n[Character {total_characters}] {char_state.name}")

        # Create bot with config
        bot = TradingBot(
            character_name=char_state.name,
            config=config,
        )

        try:
            # Connect
            print(f"\n[Connect] Connecting to {config.connection.host}:{config.connection.port}...")
            await bot.connect(
                host=config.connection.host,
                port=config.connection.port,
            )
            print("  Connected!")

            # Initialize knowledge
            bot.init_knowledge(config.connection.host, config.connection.port)

            # Initialize strategy
            bot.init_strategy()

            # Login
            print(f"\n[Login] Logging in as {char_state.name}...")
            await bot.login_sequence(
                game_password=config.connection.game_password,
                character_password=config.character.password,
                username=char_state.name,
            )
            print("  Logged in!")

            # Initial orientation
            print("\n[Orient] Getting initial state...")
            state = await bot.orient(force_scan=True)
            char_state.update_from_game_state(state)

            print(f"  Context: {state.context}")
            print(f"  Sector: {state.sector}")
            print(f"  Credits: {state.credits:,}" if state.credits else "  Credits: Unknown")

            # Main trading loop
            await run_trading_loop(bot, config, char_state)

            # Save character state
            multi_char.save_character(char_state)
            total_profit += char_state.total_profit

            # Check if we hit the goal
            if char_state.credits >= config.session.target_credits:
                print(f"\n{'='*60}")
                print(f"TARGET REACHED: {char_state.credits:,} credits!")
                print(f"{'='*60}")
                break

        except KeyboardInterrupt:
            print("\n\nInterrupted by user")
            multi_char.save_character(char_state)
            break
        except Exception as e:
            logging.error(f"Error during gameplay: {e}")
            import traceback
            traceback.print_exc()

            # Check for death
            if "destroyed" in str(e).lower() or "died" in str(e).lower():
                print("\n*** CHARACTER DIED ***")
                char_state = multi_char.handle_death(char_state)
            else:
                multi_char.save_character(char_state)
                break
        finally:
            # Cleanup
            if bot.session_id:
                try:
                    await bot.session_manager.close_session(bot.session_id)
                except Exception:
                    pass

    # Final report
    print("\n" + "=" * 60)
    print("SESSION COMPLETE")
    print("=" * 60)
    stats = multi_char.get_aggregate_stats()
    print(f"  Characters used: {stats['total_characters']}")
    print(f"  Deaths: {stats['total_deaths']}")
    print(f"  Total profit: {stats['total_profit']:,} credits")
    print("=" * 60)


async def run_trading_loop(bot, config: BotConfig, char_state) -> None:
    """Run the main trading loop using the configured strategy."""
    import random

    strategy = bot.strategy
    if not strategy:
        strategy = bot.init_strategy()

    target_credits = config.session.target_credits
    max_turns = config.session.max_turns_per_session

    turns_used = 0

    print(f"\n[Trading] Starting {strategy.name} strategy...")

    while turns_used < max_turns:
        turns_used += 1

        # Get current state (with scan optimization)
        state = await bot.orient()
        char_state.update_from_game_state(state)

        credits = state.credits or 0
        print(f"\n[Turn {turns_used}] Sector {state.sector}, Credits: {credits:,}")

        # Check target
        if credits >= target_credits:
            print(f"\nTarget reached: {credits:,} credits!")
            break

        # Check turns
        if state.turns_left is not None and state.turns_left <= 0:
            print("\nOut of turns!")
            break

        # Get next action from strategy
        from twbot.strategies.base import TradeAction
        action, params = strategy.get_next_action(state)

        print(f"  Strategy: {action.name}")

        # Execute action
        if action == TradeAction.TRADE:
            # Execute trade
            opportunity = params.get("opportunity")
            if opportunity:
                print(f"  Trading {opportunity.commodity} (expected profit: {opportunity.expected_profit})")
                # Simplified trade execution
                profit = await execute_simple_trade(bot, state)
                if profit > 0:
                    char_state.record_trade(profit)
                    print(f"  Profit: {profit:,}")

        elif action == TradeAction.MOVE:
            target = params.get("target_sector")
            path = params.get("path", [])
            if target:
                print(f"  Moving to sector {target}")
                await warp_to_sector(bot, target)

        elif action == TradeAction.EXPLORE:
            direction = params.get("direction")
            if direction:
                print(f"  Exploring sector {direction}")
                await warp_to_sector(bot, direction)

        elif action == TradeAction.BANK:
            print("  Banking credits...")
            result = await bot.banking.deposit(bot, state)
            if result.success:
                print(f"  Deposited {result.deposited:,}")

        elif action == TradeAction.UPGRADE:
            upgrade_type = params.get("upgrade_type")
            print(f"  Upgrading: {upgrade_type}")
            # Would navigate to Stardock and buy upgrades

        elif action == TradeAction.RETREAT:
            safe_sector = params.get("safe_sector")
            print(f"  Retreating to sector {safe_sector}")
            await bot.combat.retreat(bot, state)

        elif action == TradeAction.WAIT:
            print("  No action available")
            # Try random warp to find opportunity
            if state.warps:
                target = random.choice(state.warps)
                await warp_to_sector(bot, target)

        elif action == TradeAction.DONE:
            print("  Strategy complete")
            break

        # Record result
        from twbot.strategies.base import TradeResult
        result = TradeResult(
            success=True,
            action=action,
            new_sector=bot.current_sector,
            turns_used=1,
        )
        strategy.record_result(result)

        await asyncio.sleep(0.2)


async def execute_simple_trade(bot, state) -> int:
    """Execute a simple trade at current port."""
    import asyncio
    import re

    if not state.has_port:
        return 0

    initial_credits = state.credits or 0

    # Enter port
    await bot.session.send("P")
    await asyncio.sleep(1.0)

    result = await bot.session.read(timeout_ms=2000, max_bytes=8192)
    screen = result.get("screen", "").lower()

    if "no port" in screen:
        return 0

    # Trade
    await bot.session.send("T")
    await asyncio.sleep(1.5)

    # Handle prompts
    trades = 0
    for _ in range(15):
        result = await bot.session.read(timeout_ms=1500, max_bytes=8192)
        screen = result.get("screen", "")
        screen_lower = screen.lower()

        if "command" in screen_lower and "?" in screen:
            break

        if "how many" in screen_lower:
            await bot.session.send("50\r")
            trades += 1
            await asyncio.sleep(0.5)
            continue

        if "[y/n]" in screen_lower or "(y/n)" in screen_lower:
            await bot.session.send("Y")
            await asyncio.sleep(0.3)
            continue

        if "press" in screen_lower or "pause" in screen_lower:
            await bot.session.send(" ")
            await asyncio.sleep(0.3)
            continue

        # Exit if at menu
        if "[q]" in screen_lower:
            await bot.session.send("Q")
            break

        await asyncio.sleep(0.3)

    # Exit port
    await bot.session.send("Q\r")
    await asyncio.sleep(0.3)
    await bot.recover()

    # Get new credits
    new_state = await bot.orient()
    new_credits = new_state.credits or 0

    return new_credits - initial_credits


async def warp_to_sector(bot, target: int) -> bool:
    """Warp to a sector."""
    import asyncio

    bot.loop_detection.clear()

    await bot.session.send(f"{target}\r")
    await asyncio.sleep(1.5)

    for _ in range(8):
        result = await bot.session.read(timeout_ms=1500, max_bytes=8192)
        screen = result.get("screen", "").lower()

        if "command" in screen and "?" in screen:
            break

        if "auto-warp" in screen or "engage" in screen:
            await bot.session.send("Y")
            await asyncio.sleep(0.5)
            continue

        if "density" in screen or "scan" in screen:
            await bot.session.send(" ")
            await asyncio.sleep(0.3)
            continue

        if "[y/n]" in screen or "(y/n)" in screen:
            await bot.session.send("Y")
            await asyncio.sleep(0.3)
            continue

        if "press" in screen or "pause" in screen:
            await bot.session.send(" ")
            await asyncio.sleep(0.3)
            continue

        await asyncio.sleep(0.3)

    await bot.recover()

    state = await bot.where_am_i()
    return state.sector == target


def main() -> int:
    """Main entry point."""
    args = parse_args()

    if args.generate_config:
        print(generate_default_config())
        return 0

    setup_logging(args.verbose)

    # Load config
    if args.config:
        config = load_config(args.config)
    else:
        print("No config file specified, using defaults")
        print("Use --generate-config to create a config file")
        config = BotConfig()

    # Apply overrides
    if args.host:
        config.connection.host = args.host
    if args.port:
        config.connection.port = args.port
    if args.strategy:
        config.trading.strategy = args.strategy
    if args.target_credits:
        config.session.target_credits = args.target_credits
    if args.max_turns:
        config.session.max_turns_per_session = args.max_turns

    # Run
    try:
        asyncio.run(run_bot(config))
        return 0
    except KeyboardInterrupt:
        print("\nInterrupted")
        return 130
    except Exception as e:
        logging.error(f"Fatal error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
