"""CLI helpers for TW2002 bot."""

from __future__ import annotations

import asyncio
import logging
from pathlib import Path

import yaml

from bbsbot.tw2002.config import BotConfig


def setup_logging(verbose: bool = False) -> None:
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )


def generate_default_config() -> str:
    config = BotConfig()
    data = config.model_dump(mode="json")

    output = """# TW2002 Bot Configuration
# Generated by bbsbot tw2002 bot --generate-config

"""
    output += yaml.dump(data, default_flow_style=False, sort_keys=False)
    return output


def _apply_overrides(
    config: BotConfig,
    *,
    host: str | None,
    port: int | None,
    strategy: str | None,
    target_credits: int | None,
    max_turns: int | None,
) -> None:
    if host:
        config.connection.host = host
    if port:
        config.connection.port = port
    if strategy:
        config.trading.strategy = strategy
    if target_credits:
        config.session.target_credits = target_credits
    if max_turns:
        config.session.max_turns_per_session = max_turns


def _make_watch_callback(clear: bool, show_prompt: bool = True):
    def _watch(snapshot: dict) -> None:
        if clear:
            print("\x1b[2J\x1b[H", end="")
        print(snapshot.get("screen", ""))
        if show_prompt and snapshot.get("prompt_detected"):
            detected = snapshot["prompt_detected"]
            print("")
            print(f"[prompt] {detected.get('prompt_id')} ({detected.get('input_type')})")
    return _watch


async def run_bot(
    config: BotConfig,
    *,
    watch: bool = False,
    watch_interval: float = 0.0,
    watch_clear: bool = True,
) -> None:
    """Run the trading bot with the given configuration."""
    from bbsbot.tw2002.bot import TradingBot
    from bbsbot.tw2002.multi_character import MultiCharacterManager

    print("\n" + "=" * 60)
    print("TW2002 TRADING BOT")
    print("=" * 60)
    print(f"Strategy: {config.trading.strategy}")
    print(f"Target: {config.session.target_credits:,} credits")
    print(f"Max turns: {config.session.max_turns_per_session}")
    print("=" * 60 + "\n")

    # Set up data directory
    from bbsbot.paths import default_knowledge_root

    knowledge_root = default_knowledge_root()
    data_dir = knowledge_root / "tw2002" / f"{config.connection.host}_{config.connection.port}"
    data_dir.mkdir(parents=True, exist_ok=True)

    multi_char = MultiCharacterManager(
        config=config,
        data_dir=data_dir,
        sharing_mode=config.multi_character.knowledge_sharing,
    )

    total_characters = 0
    total_profit = 0

    while total_characters < config.multi_character.max_characters:
        total_characters += 1

        char_state = multi_char.create_character()
        print(f"\n[Character {total_characters}] {char_state.name}")

        bot = TradingBot(
            character_name=char_state.name,
            config=config,
        )

        try:
            print(f"\n[Connect] Connecting to {config.connection.host}:{config.connection.port}...")
            await bot.connect(host=config.connection.host, port=config.connection.port)
            print("  Connected!")

            if watch and bot.session is not None:
                bot.session.set_watch(_make_watch_callback(clear=watch_clear), interval_s=watch_interval)

            bot.init_knowledge(config.connection.host, config.connection.port)
            bot.init_strategy()

            print(f"\n[Login] Logging in as {char_state.name}...")
            await bot.login_sequence(
                game_password=config.connection.game_password,
                character_password=config.character.password,
                username=char_state.name,
            )
            print("  Logged in!")

            print("\n[Orient] Getting initial state...")
            state = await bot.orient(force_scan=True)
            char_state.update_from_game_state(state)

            print(f"  Context: {state.context}")
            print(f"  Sector: {state.sector}")
            print(f"  Credits: {state.credits:,}" if state.credits else "  Credits: Unknown")

            await run_trading_loop(bot, config, char_state)

            multi_char.save_character(char_state)
            total_profit += char_state.total_profit

            if char_state.credits >= config.session.target_credits:
                print(f"\n{'='*60}")
                print(f"TARGET REACHED: {char_state.credits:,} credits!")
                print(f"{'='*60}")
                break

        except KeyboardInterrupt:
            print("\n\nInterrupted by user")
            multi_char.save_character(char_state)
            break
        except Exception as exc:
            logging.error("Error during gameplay: %s", exc)
            import traceback

            traceback.print_exc()

            if "destroyed" in str(exc).lower() or "died" in str(exc).lower():
                print("\n*** CHARACTER DIED ***")
                char_state = multi_char.handle_death(char_state)
            else:
                multi_char.save_character(char_state)
                break
        finally:
            if bot.session_id:
                try:
                    await bot.session_manager.close_session(bot.session_id)
                except Exception:
                    pass

    print("\n" + "=" * 60)
    print("SESSION COMPLETE")
    print("=" * 60)
    stats = multi_char.get_aggregate_stats()
    print(f"  Characters used: {stats['total_characters']}")
    print(f"  Deaths: {stats['total_deaths']}")
    print(f"  Total profit: {stats['total_profit']:,} credits")
    print("=" * 60)


async def run_trading_loop(bot, config: BotConfig, char_state) -> None:
    """Run the main trading loop using the configured strategy."""
    import random

    # This function remains unchanged; existing implementation follows.
    from bbsbot.tw2002.cli_impl import run_trading_loop as _impl

    await _impl(bot, config, char_state)


def run_bot_cli(
    *,
    config_path: str | None,
    generate_config: bool,
    host: str | None,
    port: int | None,
    verbose: bool,
    strategy: str | None,
    target_credits: int | None,
    max_turns: int | None,
    watch: bool,
    watch_interval: float,
    watch_clear: bool,
) -> None:
    if generate_config:
        print(generate_default_config())
        return

    if config_path:
        config = BotConfig.from_yaml(Path(config_path))
    else:
        config = BotConfig()

    _apply_overrides(
        config,
        host=host,
        port=port,
        strategy=strategy,
        target_credits=target_credits,
        max_turns=max_turns,
    )

    setup_logging(verbose)
    asyncio.run(run_bot(config, watch=watch, watch_interval=watch_interval, watch_clear=watch_clear))
