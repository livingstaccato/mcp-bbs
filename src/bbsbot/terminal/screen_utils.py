# Copyright (c) 2025-2026 provide.io llc
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Generic screen parsing utilities for BBS terminals.

This module provides reusable screen parsing functions that can be used
across different games and BBS systems.
"""

import re

_ANSI_ESCAPE_RE = re.compile(r"\x1b(?:\[[0-?]*[ -/]*[@-~]|[@-_])")
# Some TWGS/telnet bursts occasionally leak bare SGR fragments like `1;31m` at line
# starts without the ESC prefix. Strip only when they look isolated.
_BARE_SGR_RE = re.compile(r"(?:(?<=^)|(?<=\n)|(?<=\r)|(?<=\s))(?:\d{1,3}(?:;\d{1,3})*)m(?=\x1b|\s|$)")
_BARE_SGR_LINE_PREFIX_RE = re.compile(r"(?m)^(?:\d{1,3}(?:;\d{1,3})*)m(?=[A-Z<])")
_ACTION_TAG_RE = re.compile(r"<([^<>\r\n]{1,80})>")


def normalize_terminal_text(text: str) -> str:
    """Normalize terminal text for robust prompt/context parsing.

    - Removes ANSI escape/control sequences.
    - Removes isolated bare SGR fragments (e.g. ``1;31m``) seen in some TWGS output.
    - Normalizes line endings.
    """
    if not text:
        return ""
    cleaned = text.replace("\r\n", "\n").replace("\r", "\n")
    cleaned = _ANSI_ESCAPE_RE.sub("", cleaned)
    cleaned = _BARE_SGR_LINE_PREFIX_RE.sub("", cleaned)
    cleaned = _BARE_SGR_RE.sub("", cleaned)
    return cleaned


def extract_action_tags(text: str, *, max_tags: int = 8) -> list[str]:
    """Extract angle-bracket action tags like ``<Move>`` from a screen snapshot."""
    if not text:
        return []
    out: list[str] = []
    seen: set[str] = set()
    for raw in _ACTION_TAG_RE.findall(text):
        tag = str(raw or "").strip()
        if not tag:
            continue
        key = tag.lower()
        if key in seen:
            continue
        seen.add(key)
        out.append(tag)
        if len(out) >= max(1, int(max_tags)):
            break
    return out


def clean_screen_for_display(screen: str, max_lines: int = 30) -> list[str]:
    """Clean screen for display by removing padding lines.

    Args:
        screen: Raw screen text
        max_lines: Maximum lines to return

    Returns:
        List of non-empty content lines (up to max_lines)
    """
    lines = []
    for line in screen.split("\n"):
        # Skip pure padding (80+ spaces) and empty lines
        if line.strip() or not line.startswith(" " * 80):
            lines.append(line)
            if len(lines) >= max_lines:
                break
    return lines


def extract_menu_options(screen: str, pattern: str | None = None) -> list[tuple[str, str]]:
    """Extract menu options from screen text.

    Supports common menu formats like:
    - <A> Option Name
    - [A] Option Name
    - (A) Option Name

    Args:
        screen: Screen text containing menu options
        pattern: Optional custom regex pattern. If None, uses default bracket patterns.
                Must have two capture groups: (key, description)

    Returns:
        List of (key, description) tuples, e.g., [('A', 'My Game'), ('B', 'Game 2')]
    """
    if pattern is None:
        # Default pattern for bracket-style menus: <A> or [A] or (A)
        # Handles cases where multiple options are on the same line like "<A> Game1  <B> Game2"
        pattern = r"[<\[\(]([A-Z0-9])[>\]\)]\s+([^<\[\(\n]+?)(?=\s*[<\[\(]|$)"

    options = []
    for match in re.finditer(pattern, screen):
        key = match.group(1)
        description = match.group(2).strip()
        if description:
            options.append((key, description))

    return options


def extract_numbered_list(screen: str, pattern: str | None = None) -> list[tuple[str, str]]:
    """Extract numbered lists from screen text.

    Supports common numbered formats like:
    - 1. Option Name
    - 1) Option Name
    - 1 - Option Name

    Args:
        screen: Screen text containing numbered list
        pattern: Optional custom regex pattern. If None, uses default numbered patterns.
                Must have two capture groups: (number, description)

    Returns:
        List of (number, description) tuples
    """
    if pattern is None:
        # Default pattern for numbered lists
        pattern = r"^\s*(\d+)[\.\)]\s+(.+)$"

    options = []
    for line in screen.splitlines():
        match = re.search(pattern, line)
        if match:
            number = match.group(1)
            description = match.group(2).strip()
            if description:
                options.append((number, description))

    return options


def extract_key_value_pairs(screen: str, patterns: dict[str, str]) -> dict[str, str | int]:
    """Extract key-value pairs from screen text using provided patterns.

    Args:
        screen: Screen text to parse
        patterns: Dictionary mapping field names to regex patterns.
                 Each pattern should have one capture group for the value.

    Returns:
        Dictionary of extracted values (as strings)

    Example:
        patterns = {
            "credits": r"Credits?:?\\s*([\\d,]+)",
            "sector": r"Sector\\s*:?\\s*(\\d+)"
        }
        result = extract_key_value_pairs(screen, patterns)
        # Returns: {"credits": "1,000", "sector": "42"}
    """
    data = {}
    for field, pattern in patterns.items():
        match = re.search(pattern, screen, re.IGNORECASE)
        if match:
            data[field] = match.group(1)
    return data


def strip_ansi_codes(text: str) -> str:
    """Remove ANSI escape codes from text.

    Args:
        text: Text potentially containing ANSI codes

    Returns:
        Text with ANSI codes removed
    """
    # Keep backward-compatible function name, but route through the improved normalizer.
    return normalize_terminal_text(text)
