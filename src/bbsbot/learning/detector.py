"""Prompt detection with cursor-aware pattern matching.

End-state goals:
- Avoid full-screen regex scans on every frame (most prompts are near the bottom).
- Reduce false positives from stale/header content by prioritizing the prompt region.
"""

from __future__ import annotations

import re
from typing import Any
import hashlib

from pydantic import BaseModel, ConfigDict

from bbsbot.learning.buffer import ScreenBuffer
from bbsbot.logging import get_logger

logger = get_logger(__name__)

_DEFAULT_PROMPT_REGION_TAIL_LINES = 12


class PromptMatch(BaseModel):
    """Represents a matched prompt pattern."""

    prompt_id: str
    pattern: dict[str, Any]
    input_type: str  # "single_key" | "multi_key" | "any_key"
    eol_pattern: str
    kv_extract: list[dict[str, Any]] | dict[str, Any] | None = None


class PromptDetection(BaseModel):
    """Complete prompt detection result with context."""

    prompt_id: str
    input_type: str
    is_idle: bool
    buffer: ScreenBuffer
    kv_data: dict[str, Any] | None = None

    model_config = ConfigDict(arbitrary_types_allowed=True)


class PromptDetector:
    """Intelligent prompt detection with cursor-awareness."""

    def __init__(self, patterns: list[dict[str, Any]]) -> None:
        """Initialize prompt detector.

        Args:
            patterns: List of prompt pattern dictionaries from JSON
        """
        self._patterns = patterns
        self._compiled_all = self._compile_patterns()
        # Optimization only: patterns that *don't* require cursor-at-end.
        # IMPORTANT: do not treat cursor_at_end as authoritative; if the heuristic is wrong
        # and we skip "expect_cursor_at_end=true" patterns entirely, prompt detection can fail.
        self._compiled_no_cursor_end_req = [
            (regex, pattern)
            for (regex, pattern) in self._compiled_all
            if not bool(pattern.get("expect_cursor_at_end", True))
        ]

    def _compile_patterns(self) -> list[tuple[re.Pattern[str], dict[str, Any]]]:
        """Compile regex patterns for efficient matching.

        Returns:
            List of (compiled_regex, pattern_dict) tuples
        """
        compiled = []
        failed_patterns = []

        logger.info(f"[PATTERN COMPILE] Compiling {len(self._patterns)} patterns")

        for pattern in self._patterns:
            try:
                regex = re.compile(pattern["regex"], re.MULTILINE)
                compiled.append((regex, pattern))
                logger.debug(f"[PATTERN COMPILE] ✓ Compiled: {pattern.get('id', 'unknown')}")
            except re.error as e:
                # Pattern compilation failed - emit diagnostic
                failed_patterns.append({
                    "id": pattern.get("id", "unknown"),
                    "regex": pattern.get("regex", ""),
                    "error": str(e),
                })
                logger.error(
                    f"[PATTERN COMPILE] ✗ FAILED to compile pattern: {pattern.get('id', 'unknown')}\n"
                    f"  Regex: {pattern.get('regex', '')!r}\n"
                    f"  Error: {e}"
                )
                continue
            except KeyError as e:
                # Pattern missing required 'regex' key
                logger.error(
                    f"[PATTERN COMPILE] ✗ INVALID pattern structure (missing key): {pattern.get('id', 'unknown')}\n"
                    f"  Missing key: {e}\n"
                    f"  Pattern keys: {list(pattern.keys())}"
                )
                failed_patterns.append({
                    "id": pattern.get("id", "unknown"),
                    "error": f"Missing key: {e}",
                })
                continue

        logger.info(
            f"[PATTERN COMPILE] Compilation complete: {len(compiled)} succeeded, "
            f"{len(failed_patterns)} failed"
        )

        if failed_patterns:
            logger.error(
                f"[PATTERN COMPILE] ⚠️  {len(failed_patterns)} patterns failed compilation:\n" +
                "\n".join(f"  - {p['id']}: {p.get('error', 'unknown error')}" for p in failed_patterns)
            )

        return compiled

    @staticmethod
    def prompt_region(
        snapshot: dict[str, Any],
        *,
        tail_lines: int = _DEFAULT_PROMPT_REGION_TAIL_LINES,
    ) -> tuple[str, bool]:
        """Extract a bottom-of-content region likely to contain prompts.

        Returns (region_text, cursor_in_region).

        We anchor to the last non-empty line of the screen, not the bottom row,
        because many UIs leave blank rows below the last content.
        """
        screen = snapshot.get("screen", "") or ""
        if not screen:
            return ("", False)

        # Preserve empty trailing lines if present.
        lines = screen.split("\n")
        # Find the last line with any non-whitespace content.
        last_idx = 0
        for i in range(len(lines) - 1, -1, -1):
            if lines[i].rstrip():
                last_idx = i
                break
        start_idx = max(0, last_idx - max(1, int(tail_lines)) + 1)

        cursor = snapshot.get("cursor") or {}
        try:
            cursor_y = int(cursor.get("y", 0) or 0)
        except Exception:
            cursor_y = 0
        cursor_in_region = start_idx <= cursor_y <= last_idx

        region_text = "\n".join(lines[start_idx : last_idx + 1])
        return (region_text, cursor_in_region)

    @staticmethod
    def normalize_prompt_region(region_text: str) -> str:
        """Normalize volatile prompt-region fields for stable fingerprinting."""
        if not region_text:
            return ""
        text = region_text
        # Command prompt contains a timer field that changes every second.
        text = re.sub(r"(?i)TL=\d\d:\d\d:\d\d", "TL=00:00:00", text)
        # On TW2002 command prompts we often see `:[4]` changing; normalize only when
        # it looks like the command prompt line, to avoid mangling other prompts.
        if re.search(r"(?i)command\s*\[TL=", text):
            text = re.sub(r":\[\d+\]", ":[#]", text)
        return text

    @staticmethod
    def prompt_fingerprint(
        snapshot: dict[str, Any],
        *,
        tail_lines: int = _DEFAULT_PROMPT_REGION_TAIL_LINES,
    ) -> str:
        """Compute a stable fingerprint for prompt-detection caching."""
        region, _cursor_above = PromptDetector.prompt_region(snapshot, tail_lines=tail_lines)
        norm = PromptDetector.normalize_prompt_region(region)
        h = hashlib.blake2s(norm.encode("utf-8", errors="replace")).hexdigest()
        cursor_at_end = int(bool(snapshot.get("cursor_at_end", True)))
        trailing = int(bool(snapshot.get("has_trailing_space", False)))
        return f"{h}:{cursor_at_end}:{trailing}"

    def _detect_in_text(
        self,
        *,
        text: str,
        full_screen: str,
        cursor_at_end: bool,
        compiled: list[tuple[re.Pattern[str], dict[str, Any]]],
        regex_matched_but_failed: list[dict[str, Any]],
        cursor_miss_candidates: list["PromptMatch"] | None = None,
    ) -> PromptMatch | None:
        for regex, pattern in compiled:
            match = regex.search(text)
            if not match:
                continue

            negative = pattern.get("negative_regex")
            if negative and re.search(negative, full_screen, re.MULTILINE | re.IGNORECASE):
                regex_matched_but_failed.append(
                    {
                        "pattern_id": pattern["id"],
                        "reason": "negative_match",
                        "negative_pattern": negative,
                    }
                )
                continue

            expect_cursor_at_end = pattern.get("expect_cursor_at_end", True)
            if expect_cursor_at_end and not cursor_at_end:
                regex_matched_but_failed.append(
                    {
                        "pattern_id": pattern["id"],
                        "reason": "cursor_position",
                        "expected_cursor_at_end": expect_cursor_at_end,
                        "actual_cursor_at_end": cursor_at_end,
                    }
                )
                # Cursor-at-end is a heuristic; on some screens (or some telnet bursts)
                # pyte cursor bookkeeping can be off. Preserve a fallback candidate so
                # callers can still make progress instead of timing out forever.
                if cursor_miss_candidates is not None:
                    cursor_miss_candidates.append(
                        PromptMatch(
                            prompt_id=pattern["id"],
                            pattern=pattern,
                            input_type=pattern.get("input_type", "multi_key"),
                            eol_pattern=pattern.get("eol_pattern", r"[\r\n]+"),
                            kv_extract=pattern.get("kv_extract"),
                        )
                    )
                continue

            return PromptMatch(
                prompt_id=pattern["id"],
                pattern=pattern,
                input_type=pattern.get("input_type", "multi_key"),
                eol_pattern=pattern.get("eol_pattern", r"[\r\n]+"),
                kv_extract=pattern.get("kv_extract"),
            )
        return None

    def detect_prompt(self, snapshot: dict[str, Any]) -> PromptMatch | None:
        """Detect if snapshot contains a prompt waiting for input.

        Args:
            snapshot: Screen snapshot with timing and cursor metadata

        Returns:
            PromptMatch if a prompt pattern matches, None otherwise
        """
        screen = snapshot.get("screen", "") or ""
        # Most callers supply cursor metadata; tests/legacy callers may not.
        # Defaulting to True keeps prompt detection working for minimal snapshots.
        cursor_at_end = snapshot.get("cursor_at_end", True)
        has_trailing_space = snapshot.get("has_trailing_space", False)

        # Track patterns that partially matched (for diagnostics)
        regex_matched_but_failed: list[dict[str, Any]] = []

        logger.debug(f"[PROMPT DETECTION] Checking {len(self._compiled_all)} patterns")
        logger.debug(f"[PROMPT DETECTION] Cursor at end: {cursor_at_end}, Has trailing space: {has_trailing_space}")
        if screen:
            region_text, cursor_in_region = self.prompt_region(snapshot)
            logger.debug(
                f"[PROMPT DETECTION] Region ({len(region_text)} chars, cursor_in={cursor_in_region}):\n"
                f"{region_text[-200:]}"
            )

        # Candidate pattern set: always allow all patterns; cursor constraints are checked per-pattern.
        compiled_all = self._compiled_all
        compiled_fast = self._compiled_no_cursor_end_req if not cursor_at_end else self._compiled_all

        # Two-pass scan: first scan the prompt region (bottom-of-content),
        # then fall back to full-screen scan if the cursor isn't within that region.
        cursor_miss_candidates: list[PromptMatch] = []
        region_text, cursor_in_region = self.prompt_region(snapshot)
        if region_text:
            match = self._detect_in_text(
                text=region_text,
                full_screen=screen,
                cursor_at_end=bool(cursor_at_end),
                compiled=compiled_fast,
                regex_matched_but_failed=regex_matched_but_failed,
                cursor_miss_candidates=cursor_miss_candidates,
            )
            if match:
                logger.info(
                    f"[PROMPT DETECTION] ✓✓✓ MATCHED (region): {match.prompt_id} "
                    f"(input_type: {match.input_type})"
                )
                return match

        if not cursor_in_region:
            match = self._detect_in_text(
                text=screen,
                full_screen=screen,
                cursor_at_end=bool(cursor_at_end),
                compiled=compiled_all,
                regex_matched_but_failed=regex_matched_but_failed,
                cursor_miss_candidates=cursor_miss_candidates,
            )
            if match:
                logger.info(
                    f"[PROMPT DETECTION] ✓✓✓ MATCHED (full): {match.prompt_id} "
                    f"(input_type: {match.input_type})"
                )
                return match

        # Fallback: if we matched prompt regexes but the cursor heuristic disagreed, prefer progress.
        # Gate this on "trailing space" which strongly correlates with an active input field.
        if cursor_miss_candidates and not bool(cursor_at_end) and bool(has_trailing_space):
            cand = cursor_miss_candidates[0]
            logger.warning(
                "[PROMPT DETECTION] Cursor-at-end heuristic blocked prompt match; "
                f"falling back to {cand.prompt_id}"
            )
            return cand

        # NO PATTERNS MATCHED - Emit diagnostic
        if regex_matched_but_failed:
            logger.error(
                f"[PROMPT DETECTION] ✗✗✗ DETECTION FAILED: {len(regex_matched_but_failed)} patterns matched "
                f"regex but failed additional checks:\n" +
                "\n".join(f"  - {p['pattern_id']}: {p['reason']}" for p in regex_matched_but_failed)
            )
        else:
            # No patterns matched at all - this might be okay (e.g., data display)
            logger.debug(
                f"[PROMPT DETECTION] No patterns matched screen content\n"
                f"  Total patterns: {len(self._compiled_all)}\n"
                f"  Screen preview: {screen[-150:]!r}"
            )

        return None

    def auto_detect_input_type(self, screen: str) -> str:
        """Heuristically detect input type from prompt text.

        Args:
            screen: Screen text to analyze

        Returns:
            "any_key", "single_key", or "multi_key"
        """
        screen_lower = screen.lower()

        # "Press any key" type prompts
        if any(
            phrase in screen_lower
            for phrase in [
                "press any key",
                "press a key",
                "hit any key",
                "strike any key",
                "<more>",
                "[more]",
                "-- more --",
            ]
        ):
            return "any_key"

        # Single key choice prompts (Y/N, menu selections)
        if any(
            phrase in screen_lower
            for phrase in [
                "(y/n)",
                "(yes/no)",
                "continue?",
                "quit?",
                "abort?",
                "retry?",
                "[y/n]",
                "(q)uit",
                "(a)bort",
            ]
        ):
            return "single_key"

        # Multi-key field input prompts
        if any(
            phrase in screen_lower
            for phrase in [
                "enter",
                "type",
                "input",
                "name:",
                "password:",
                "username:",
                "choose:",
                "select:",
                "command:",
                "search:",
            ]
        ):
            return "multi_key"

        # Default to multi_key (safest, waits for EOL)
        return "multi_key"

    def add_pattern(self, pattern: dict[str, Any]) -> None:
        """Add a new pattern to the detector.

        Args:
            pattern: Pattern dictionary to add
        """
        self._patterns.append(pattern)
        # Recompile patterns
        self._compiled = self._compile_patterns()

    def reload_patterns(self, patterns: list[dict[str, Any]]) -> None:
        """Replace all patterns with new set.

        Args:
            patterns: New list of pattern dictionaries
        """
        self._patterns = patterns
        self._compiled = self._compile_patterns()
